ΓΕΩΡΓΙΑ ΕΥΑΓΓΕΛΟΥ 
ΑΜ: 1115202000050

mvote main :

Ξεκινάμε στην main παίρνοντας το αρχείο και το μέγεθος των κάδων για τον πίνακα κατακερματισμού από το command line.
Ελέγχουμε αν ο αριθμός των command line arguments είναι ο αναμενόμενος σύμφωνα με το 
Usage: ./mvote -f registeredvoters -b bucketentries
Στη συνέχεια λαμβάνουμε το αρχείο και το bucketentries στις αντίστοιχες μεταβλητές μας,
κάνοντας τους κατάλληλους ελέγχους για λάθη.
Ανοίγουμε το αρχείο και με την συνάρτηση get_voters φτιάχνουμε έναν πίνακα με όλα τα δεδομένα του αρχείου,
έχοντας σε κάθε γραμμή του πίνακα voters τις πληροφορίες για έναν ψηφοφόρο.
Καλούμε την συνάρτηση prompt_implementation για να ξεκινήσουμε την εκτέλεση του prompt.
Τέλος κλείνουμε το αρχείο και τελειώνουμε την εκτέλεση του main.
 
mvote_Implemantation :

Στο αρχείο αυτό ξεκινάμε ορίζοντας την global μεταβλητή bytes την οποία θα χρησιμοποιήσουμε
για να υπολογίσουμε τον αριθμό των bytes που θα δεσμεύσουμε και θα ελευθερώσουμε τελικα,
κατά την εκτέλεση του προγράμματός μας. Κάθε φορά που θα συναντάμε κάποια malloc ή realloc 
θα ενημερώνουμε κατάλληλα την μεταβλητή.

get_voters :

Η συνάρτηση αυτή καλείται από την main με ορίσματα το αρχείο που διαβάσαμε στο command line 
και τον αριθμό των ψηφοφόρων ο οποίος αρχικά είναι 0. περνάμε το αρχείο μια φορά για να υπολογίσουμε
το numVoters, και στη συνέχεια το ξαναπερνάμε για να πάρουμε τις πληροφορίες απότο αρχείο 
και να τις τοποθετήσουμε στον πίνακα voters τον οποίο επιστρέφουμε στη main. 

Prompt Implementation : 

Αρχίζουμε την εκτέλεσης αυτής της συνάρτησης κάνοντας τις κατάλληλες δεσμεύσεις / αρχικοποιήσεις για το
Hash Table που αρχικοποιούμε με τα δεδομένα του πίνακα voters και για την λίστα ZL που θα χρησιμοποιήσουμε
στη συνέχεια ως ευρετήριο μέσω των zipcodes. 

Ξεκινάμε την επανάληψη για την εκτέλεση του prompt χρησιμοποιώντας exit_flag = 0 
εως ώστου αλλάξει από την εντολή exit.
Εκτυπώνουμε την ετικέτα του prompt (mvote-promt >>) και διαβάζουμε στο input 
την εντολή που θα δωθεί κάθε φορά, την οποία επεξεργαζόμαστε με το if που ελέγχει τις εξής εκδοχές: 

Command: l <pin>

Ελέγχουμε με την εντολή strncmp(input, "l ", 2) == 0 αν η εντολή που δώθηκε έχει την κατάλληλη μορφή.
Στη συνέχεια με την εντολή sscanf(input, "l %d", &pin) == 1 ελέγχουμε οτι δώθηκε pin που είναι ακέραιο και θετικό.
Αν τελικά η εντολή έχει δωθεί σωστά ψάχνουμε με τη βοήθεια του Hash Table τον ψηφοφόρο με pin χρησιμοποιώντας 
την συνάρτηση get_voter_info και εκτυπώνουμε τις πληροφορίες του, αλλιώς εκτυπώνουμε κατάλληλο μύνημα λάθους.

Command: i <pin> <lname> <fname> <zip>

Ελέγχουμε με την εντολή strncmp(input, "i ", 2) == 0 αν η εντολή που δώθηκε έχει την κατάλληλη μορφή.
Στη συνέχεια με την εντολή sscanf(input,"i %d %99s %99s %d", &pin, lname, fname, &zip) == 4
ελέγχουμε οτι δώθηκε pin που είναι ακέραιο, επίθετο και όνομα που περιέχει χαρακτήρες και ταχυφρομικός κώδικας ακέραιος.
Αν τελικά η εντολή έχει δωθεί σωστά ψάχνουμε με τη βοήθεια του Hash Table τον ψηφοφόρο με pin αν υπάρχει ήδη,
αλλιώς τον προσθέτουμε στον πίνακα voters ,ενημερώνουμε κατάλληλα το Hash Table και εκτυπώνουμε ενημερωτικό μύνημα,
αλλιώς εκτυπώνουμε κατάλληλο μύνημα λάθους.

Command: m <pin>

Ελέγχουμε με την εντολή strncmp(input, "m ", 2) == 0 αν η εντολή που δώθηκε έχει την κατάλληλη μορφή.
Στη συνέχεια με την εντολή sscanf(input, "m %d", &pin) == 1 ελέγχουμε οτι δώθηκε pin που είναι ακέραιο και θετικό.
Αν τελικά η εντολή έχει δωθεί σωστά καλούμε την συνάρτηση commandm, αλλιώς εκτυπώνουμε κατάλληλο μύνημα λάθους.

commandm:

Η συνάρτηση αυτή ψάχνει μέσα από το Hash Table την θέση του ψηφοφόρου με pin και θέτει την μεταβλητή vote ως 'Υ'
ώστε να μαρκαριστεί οτί έχει ψηφίσει, αυξάνουμε την μεταβλητή count στην οποία κρατάμε τον αριθμό των ψηφοφόρων που έχουν ψηφίσει,
ενημερώνουμε την ZL με τον καινούριο ψηφοφόρο (insertinList) και ύστερα απ την εισαγωγή του ταξινομούμε εκ νέου τη λίστα (sort_list).

Command: bv <fileofkeys>

Ελέγχουμε με την εντολή strncmp(input, "bv ", 3) == 0 αν η εντολή που δώθηκε έχει την κατάλληλη μορφή.
Στη συνέχεια με την εντολή sscanf(input, "bv %ms", &fileofkeys) == 1 ελέγχουμε οτι δώθηκε αρχείο fileofkeys,
το οποίο στη συνέχεια ανοίγουμε και μετράμε τον αριθμό από ταχυδρομικούς κώδικες που περιέχει.
Ξαναδιαβάζουμε ένα ένα τους ταχυδρομικούς κώδικες και καλούμε την συνάρτηση commandm για καθένα τους ώστε να γίνουν οι κατάλληλες ενημερώσεις.
Αν παρουσιαστεί οποιοδήποτε λάθος εκτυπώνουμε κατάλληλο μύνημα.

Command: v

Ελέγχουμε με την εντολή strcmp(input, "v") == 0 αν η εντολή που δώθηκε έχει την κατάλληλη μορφή.
Αν η εντολή έχει δωθεί σωστά εκτυπώνουμε κατάλληλο μύνημα με τη μεταβλητή count η οποία περιέχει τον αριθμό ψηφοφόρων μέχρι στιγμής.

Command: perc

Ελέγχουμε με την εντολή strcmp(input, "perc") == 0 αν η εντολή που δώθηκε έχει την κατάλληλη μορφή.
Αν η εντολή έχει δωθεί σωστά εκτυπώνουμε κατάλληλο μύνημα με τη μεταβλητή perc η οποία περιέχει το ποσοστό των ψηφοφόρων που έχουν ψηφίσει
μέχρι στιγμής ως προς τον συνολικό αριθμό των συμμετοχώντων στην ψηφοφορία (count * 100 / numVoters).

Command: z <zipcode>

Ελέγχουμε με την εντολή strncmp(input, "z ", 2) == 0 αν η εντολή που δώθηκε έχει την κατάλληλη μορφή.
Στη συνέχεια με την εντολή sscanf(input, "z %d", &zip) διαβάζουμε στην μεταβλητή zip τον ταχυφρομικό κώδικα που δώθηκε.
Διαπερνάμε τη λίστα ZL εως ώτου βρούμε το zip και να εκτυπώσουμε τα pin των αντίστοιχων ψηφοφόρων.

Command: o

Ελέγχουμε με την εντολή strcmp(input, "ο") == 0 αν η εντολή που δώθηκε έχει την κατάλληλη μορφή.
Καλούμε την συνάρτηση printZipList η οποία είναι ήδη ταξινομημένη με τον κατάλληλο τρόπο.

Command: exit

Ελέγχουμε με την εντολή strcmp(input, "exit") == 0 αν η εντολή που δώθηκε έχει την κατάλληλη μορφή.
Αν η εντολή είναι σωστή μεταβάλουμε την μεταβλητή exit_flag σε 1 για να βγούμε από το loop του prompt.

Σε περίπτωση που δωθεί οποιοδήποτε άλλο ως εντολή εκτυπώνουμε κατάλληλο μύνημα λάθους.
Τέλος ελευθερώνουμε όλες τις δομές που είχαμε δεσμεύσει και εμφανίζουμε κατάλληλο μύνημα με τον αριθμό των bytes που ελευθερώθηκαν.

Inverted Index :

Η λίστα ZL έχει περιεχόμενα της εξής μορφής :
typedef struct listvoters{
    Voter* v;
    struct listvoters* nextv;
}ListV;

typedef struct zipcode{
    int countvote;              
    int zip;
    ListV* lv;                  
    struct zipcode* next;
}ZipList;

Πρόκειται δηλαδή για μια λίστα από ταχυδρομικούς κώδικες και λίστες δεικτών στον πίνακα voters.
Επομένως με την συνάρτηση insertinList κάνουμε τα εξής:
Στην περίπτωση που γίνεται η πρώτη εισαγωγή στην λίστα , την αρχικοποιούμε κατάλληλα με τις πληροφορίες του ψηφοφόρου v.
Αν η λίστα δεν είναι άδεια την προσπελαύουμε για να ελέγξουμε αν ο ταχυδρομικός κώδικας του v υπάρχει ήδη στη λίστα και τον προσθέτουμε
στην ήδη υπάρχουσα λίστα του ταχυδρομικού κώδικα. Αλλιώς δημιουργούμε καινούριο κόμβο στο τέλος της λίστας ZL.

Linear Hashing :

Το Hash Table το ορίζουμε ως εξής: 

typedef struct bucket{
    Key* keys;
    struct bucket* nextB;        
    int cap;                    
}Bucket;

typedef struct hashtable{
    Bucket** table;
    int num_buckets;
    int round;
    int p;
    int num_keys;
    int prev_num_buck;
}HashT;

Επομένως με τις συναρτήσεις initializeHashTable και initializeBucket αρχικοποιούμε τη δομή του με m 
κάδους των m θέσεων, και κατάλληλες τιμές στα υπόλλοιπα ορίσματα.
Οι συναρτήσεις insert_key, insert και split_bucket εκτελούν την λειτουργία γραμμικού κατακερματισμού
όπως περιγράφεται στο συνεδευτικό κείμενο για linear hashing που δώθηκε.
Η συνάρτηση hashfunction υπολογίζει την κατάλληλη συνάρτηση κατακερματισμού hi(k) = k mod 2^i * m.
Τέλος η βοηθητική συνάρτηση ελέγχει αν κάποιος κάδος είναι γεμάτος.